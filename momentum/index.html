
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <title></title>
    <style>

        body {
            background: #ccc;
        }

        #container {
            height: 600px;
            background: #ddd;
            -webkit-transform: translate3d(0,0,0);
            position: relative;
        }

        #box {
            background: red;
            width: 100px;
            height: 100px;
            position: absolute;
            margin: -50px 0 0 -50px;
        }

    </style>
</head>
<body>

<div id="container">
    <div id="box"></div>
</div>

<div id="debug"></div>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script src="../hammer.js"></script>
<script src="../jquery.hammer.js"></script>
<script>


    /**
     * Momentum lib by @jorikdelaporik
     * @constructor
     */
    function Momentum( options )
    {
        var self = this;
        var points = [];
        var animation;


        (function() {
            var lastTime = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                window.cancelAnimationFrame =
                        window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
            }

            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function(callback, element) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };

            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function(id) {
                    clearTimeout(id);
                };
        }());


        /**
         * reset the momentum
         */
        this.reset = function() {
            points = [];
            cancelAnimationFrame(animation);
        };


        /**
         * add a point
         * @param   array  values
         */
        this.addPoint = function( values ) {
            var date = new Date();

            if(!points[1] || (points[1] && (date.getTime() - points[1].time) > 20)) {
                // add point
                points.unshift({
                    values  : values,
                    time    : date.getTime()
                });

                // allow max 2 points
                points.splice(2, 2);
            }
        };


        /**
         * calculate the distance between points
         * @return  array   distances
         */
        this.getDistances = function() {
            var p1 = points[1];
            var p2 = points[0];

            if(!p1 || !p2) {
                return [];
            }

            var distance;

            var distances = [];
            var time_diff = p2.time - p1.time;

            for(var i=0,len=p2.values.length; i<len; i++) {
                distance = (p2.values[i] - p1.values[i]) * time_diff / 60;

                distances.push( (Math.abs(distance) > options.max_distance) ? options.max_distance : distance );
            }

            return distances;
        };


        /**
         * animate the distances to create the momentum effect
         * @param   function    callback
         */
        this.animate = function( callback ) {
            var dist = this.getDistances(),
                length = dist.length,
                highest,
                last_time;

            function run(time) {
                var delta = (time - last_time) / 1000 || 0;

                for(var i=0; i<length; i++) {
                    dist[i] = dist[i] * (options.decreasement + delta);
                    highest = Math.max(Math.abs(dist[i]), 0.01);
                }

                if(highest <= 0.01) {
                    self.reset();
                }
                else {
                    last_time = time;
                    callback.apply(this, dist);

                    animation = requestAnimationFrame(run);
                }
            }

            run();
        };
    }


    var box = $("#box");
    var momentum = new Momentum({
        max_distance: 100,
        decreasement: 0.9
    });

    $("#container")
        .hammer({ drag_min_distance: 0 })
        .bind("dragstart drag dragend", function(ev) {
            switch(ev.type) {
                case 'dragstart':
                    momentum.reset();
                    break;

                case 'drag':
                    box.css({   left: ev.position.x,
                                top: ev.position.y  });

                    momentum.addPoint([ev.position.x, ev.position.y]);
                    break;

                case 'dragend':
                    var left = parseInt(box.css("left"), 10);
                    var top = parseInt(box.css("top"), 10);

                    var dir_left = -1;
                    var dir_top = -1;

                    momentum.animate(function(x, y) {
                        left += x;
                        top += y;

                        box.css({   left: left,
                                    top: top });
                    });
                    break;
            }
        });

</script>

</body>
</html>